#!/usr/bin/env python

from __future__ import print_function, division

import math
import random
import time
from Queue import PriorityQueue

import rospy
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, PoseStamped, Point, Vector3, Quaternion
from std_msgs.msg import Header, ColorRGBA
from visualization_msgs.msg import Marker
from tf.transformations import quaternion_from_euler

# Online Documentation Links
#   
#   All Visualization Messages: http://wiki.ros.org/visualization_msgs
#   Marker: http://docs.ros.org/api/visualization_msgs/html/msg/Marker.html
#   Point: http://docs.ros.org/melodic/api/geometry_msgs/html/msg/Point.html
#   OccupancyGrid: http://docs.ros.org/kinetic/api/nav_msgs/html/msg/OccupancyGrid.html


# Utilities & Constants
INITIALIZE_SLEEP_TIME = rospy.Duration(secs=1)
GRID_FIND_TIMEOUT = 5 # in secs
VISUALIZATION_PERSIST_TIME = rospy.Duration(secs=25)
POSE_VISUALIZATION_ADVANCE_RATE = 32 # in hz
SQRT2 = math.sqrt(2)

START_POINT_VIZ_ID = 1
GOAL_POINT_VIZ_ID = 2

def format_point(point):
    return "(%0.3f, %0.3f)" % (point.x, point.y)

def get_point_for_cell(grid, col, row):
        x = grid.info.origin.position.x + grid.info.resolution * col
        y = grid.info.origin.position.y + grid.info.resolution * row
        return Point(x=x, y=y)

def get_cell_for_point(grid, p):
    """Gets the column and row that a point falls on
        
    Arguments:
        grid {OccupancyGrid} -- The grid to detect the cell of
        p {Point} -- The location within the grid to find the cell of
    
    Returns:
        (Int, Int) -- The (column, row) of the 
    """
    col = int(p.x / grid.info.resolution)
    row = int(p.y / grid.info.resolution)
    return (col, row)

class Path:

    @staticmethod 
    def empty(grid, start, goal):
        """Convenience method for creating an empty path"""
        return Path(grid, {}, start, goal)
        
    def __init__(self, grid, back_pointers, start, goal):
        """Construct a path from start to goal based off the back_pointer dictionary generated by a search algorithm
        
        Arguments:
            grid {OccupancyGrid} -- Grid that the search was performed on
            back_pointers {dict<(int, int):(int, int)>} -- Dictionary from cells (col, row) to predecessor (col, row)
            start {Point} -- Starting point of search
            goal {Point} -- Destination point of search
        """
        self.poses = []
        self.final_path_length = 0
        self.start = start
        self.goal = goal

        cell = get_cell_for_point(grid, goal)
        ppoint = get_point_for_cell(grid, cell[0], cell[1])
        seq = 0
        while cell in back_pointers:
            
            # Get pose position and angle (head towards the target point. Since we're iterating
            # from goal to start, the target point is the previous one we processed)
            point = get_point_for_cell(grid, cell[0], cell[1])
            ang_yaw = math.atan2(ppoint.y - point.y, ppoint.x - point.x)
            orientation = Quaternion(*quaternion_from_euler(0, 0, ang_yaw))

            self.final_path_length += math.hypot(point.x - ppoint.x, point.y - ppoint.y)

            pose = PoseStamped(
                header=Header(seq=seq, frame_id='map'),
                pose=Pose(position=point, orientation=orientation)
            )
            self.poses.append(pose)
            cell = back_pointers[cell]
            seq += 1
            ppoint = point            

    def found(self):
        return len(self.poses) > 0

    def __str__(self):
        if self.found():
            euclid_dist = math.hypot(self.goal.x - self.start.x, self.goal.y - self.start.y)
            return "<start=%s, goal=%s, euclid_dist-%0.2f path_dist=%0.2fm(%0.1f longer) steps:%d" % \
                    (format_point(self.start), format_point(self.goal), euclid_dist, self.final_path_length, 100 * (self.final_path_length / euclid_dist - 1), len(self.poses))
        else:
            return "<no path found>"


class PathFinder:
    def __init__(self, grid):
        self.marker_pub = rospy.Publisher("/visualization_marker", Marker, queue_size=20)
        self.poseseq_pub = rospy.Publisher("/pose_sequence", PoseStamped, queue_size=1)
        self.grid = grid

        # Give roscore enough time to connect publishers and subscribers
        rospy.sleep(INITIALIZE_SLEEP_TIME)

    def find_path(self, start, goal):
        """Finds a path from the starting node to the goal node, based off an occupancy grid

        Arguments:
            grid {OccupancyGrid} -- The grid with obstacles to find a path around
            start {Point} -- The starting pose (must be in occupancy grid reference frame)
            goal {Point} -- The goal pose (must be in the occupancy grid reference frame)
        
        Keyword Arguments:
            grid_topic {str} -- The topic where an OccupancyGrid is published (default: {"/map"})
        
        Returns:        
            [PoseStamped] -- A path (sequence of poses) that the robot should take to get to the destination (empty if this is impossible)
        """
        (start_col, start_row) = self.get_cell_for_point(start)
        (goal_col, goal_row) = self.get_cell_for_point(goal)

        if start_col < 0 or start_col >= self.grid.info.width or start_row < 0 or start_row >= self.grid.info.height or \
        goal_col  < 0 or goal_col  >= self.grid.info.width or goal_row  < 0 or goal_row  >= self.grid.info.height:       
            rospy.logwarn("No path could be found. Starting point %s or ending point %s were out of bounds" % (format_point(start), format_point(goal)))
            return Path.empty(self.grid, start, goal)

        self.visualize_cell(start_col, start_row, ColorRGBA(0, 1.0, 1.0, 1.0), START_POINT_VIZ_ID)
        self.visualize_cell(goal_col, goal_row, ColorRGBA(0, 0.7, 0, 1.0), GOAL_POINT_VIZ_ID)

        if self.is_occupied(start_col, start_row):
            rospy.logwarn("No path could be found. Starting point %s is in an occupied cell" % format_point(start))
            return Path.empty(self.grid, start, goal)
        
        if self.is_occupied(goal_col, goal_row):
            rospy.logwarn("No path could be found. Goal point %s is in an occupied cell" % format_point(goal))
            return Path.empty(self.grid, start, goal)

        if start_col is goal_col and start_row is goal_row:
            rospy.loginfo("Start point %s and end point %s are in the same occupancy cell (%d, %d). Returning empty path" %(format_point(start), format_point(goal), start_col, start_row))
            return Path.empty(self.grid, start, goal)
            
        # This function uses an A* algorithm. 
        #   > The priority is calculated as cost(node) + heuristic(node).
        #   > cost(node) = path length from start to node
        #   > heuristic(node) = euclidian distance from node to goal

        #
        # Entries in the frontier are formatted as (priority, col, row, path_cost)
        #   > using a priority queue ensures that we'll always be processing the node
        #     with the lowest estimated total path cost (which is the priority)
        min_path_costs = {
            (start_col, start_row): 0
        }
        back_pointers = {}

        frontier = PriorityQueue()
        frontier.put((1, start_col, start_row, 0))

        while not frontier.empty():
            (_, col, row, path_cost) = frontier.get()

            # If there was a quicker way found to this node, ignore it
            if path_cost is not min_path_costs[(col, row)]:
                continue

            neighbors = self.get_empty_neighbors(col, row)

            for (ncol, nrow, dcost) in neighbors:
                npath_cost = path_cost + dcost

                # If this node has already been explored with a faster min_path_cost, ignore it
                if (ncol, nrow) in min_path_costs and min_path_costs[(ncol, nrow)] <= npath_cost:
                    continue

                min_path_costs[(ncol, nrow)] = npath_cost
                npriority = npath_cost + math.hypot(goal_col - ncol, goal_row - nrow)
                frontier.put((npriority, ncol, nrow, npath_cost))
                back_pointers[(ncol, nrow)] = (col, row)

                if ncol is goal_col and nrow is goal_row:
                    break

            if (goal_col, goal_row) in back_pointers:
                break

        return Path(self.grid, back_pointers, start, goal)
    
    def publish_path(self, path):

        points = None
        color = None
        if path.found():
            # Green path when found
            points = [p.pose.position for p in path.poses]
            color = ColorRGBA(0.0, 1.0, 0.0, 1.0)
        else:
            # Red path between start and goal when not found
            points = [path.start, path.goal]
            color = ColorRGBA(1.0, 0, 0, 1.0)

        # Add visualization to rviz
        marker = Marker(
                type=Marker.LINE_STRIP,
                action=Marker.ADD,
                id=0,
                lifetime=VISUALIZATION_PERSIST_TIME,
                scale=Vector3(0.035, 0.035, 0),
                header=Header(frame_id='map'),
                points=points,
                color=color
        )
        self.marker_pub.publish(marker)

        # Publish poses gradually (helps visualize progression)
        rate = rospy.Rate(hz=POSE_VISUALIZATION_ADVANCE_RATE)
        for stampedpose in reversed(path.poses):
            self.poseseq_pub.publish(stampedpose)
            rate.sleep()
            if rospy.is_shutdown():
                break
    
    def get_empty_neighbors(self, col, row):
        """Returns the neighbor cells in the form of (col, row, delta_cost) to the current cell, using 8-way connectivity"""
        neighbors = [
            (col - 1, row - 1, SQRT2), (col, row - 1, 1), (col + 1, row - 1, SQRT2),
            (col - 1, row    , 1    ),                    (col + 1, row    , 1    ),
            (col - 1, row + 1, SQRT2), (col, row + 1, 1), (col + 1, row + 1, SQRT2)
        ]
        on_map_neighbors = [n for n in neighbors if n[0] >= 0 and n[0] < self.grid.info.width and n[1] >= 0 and n[1] < self.grid.info.height]
        return [n for n in on_map_neighbors if not self.is_occupied(col, row)]

    def get_cell_for_point(self, p):
        return get_cell_for_point(self.grid, p)

    def is_occupied(self, col, row):
        return self.grid.data[col + self.grid.info.width * row] > 50

    def get_point_for_cell(self, col, row):
        return get_point_for_cell(self.grid, col, row)

    def visualize_cell(self, col, row, color, id):
        marker = Marker(
                type=Marker.SPHERE,
                action=Marker.ADD,
                id=id,
                lifetime=VISUALIZATION_PERSIST_TIME,
                scale=Vector3(0.3, 0.3, 0.0),
                header=Header(frame_id='map'),
                pose=Pose(position=self.get_point_for_cell(col, row), orientation=Quaternion()),
                points=[self.get_point_for_cell(col, row)],
                color=color
        )
        self.marker_pub.publish(marker)

if __name__ == "__main__":  
    rospy.init_node("path_finder")

    grid = rospy.wait_for_message("/map", OccupancyGrid, GRID_FIND_TIMEOUT)
    pathfinder = PathFinder(grid)

    w = grid.info.resolution * grid.info.width
    h = grid.info.resolution * grid.info.height

    while not rospy.is_shutdown():
        start = Point(random.random() * w, random.random() * h, 0)
        end = Point(random.random() * w, random.random() * h, 0)

        rospy.loginfo("Finding a path from %s to %s" % (format_point(start), format_point(end)))
        path = pathfinder.find_path(start, end)

        rospy.loginfo("Path find result: %s" % str(path))
        pathfinder.publish_path(path)

        rospy.sleep(rospy.Duration(secs=3.0))